<html>
<head>
    <title>Native HTTP/HTML Video Streaming</title>
    <script src="./js/jquery-3.5.1.min.js"></script>
</head>
<body>
    <div id="div-canvas">
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    <div id="div-info">
    </div>
<script>
    $( document ).ready(function() {
        console.log( "ready!" );

        var url = "http://localhost:8888";
        const consume = async function (responseReader, boundary) {
            if (typeof consume.boundary === "undefined") {
                console.log(["consume", boundary]);
                consume.boundary = "--" + boundary;
                consume.reaminingBytes = 0;
                consume.bodyPart = new Uint8Array();
                consume.line = "";
                consume.parserStatus = 0;
            }
            return responseReader.read().then(function (result) {
                if (result.done) { return; }

                // do something with the current chunk
                const chunk = result.value;

                // since the chunk can be multiple bytes, iterate through
                // each byte while skipping the byte order mark
                // (assuming UTF-8 with single-byte chars)
                //console.log(["CHUNK", chunk.byteLength]);
                /*for (var i = 0; i < chunk.byteLength; i++) {
                    line += String.fromCharCode(chunk[i]);
                }
                console.log(line);
                line = '';*/
                for (var i = 0; i < chunk.byteLength; i++) {
                    if (consume.parserStatus == 2 && consume.remainingBytes > 0) {
                        var incomingData = chunk.slice(i, i + consume.remainingBytes);
                        //console.log(["bytes read", incomingData.byteLength]);
                        consume.remainingBytes -= incomingData.byteLength;
                        i += incomingData.byteLength;

                        var joined = new Uint8Array(consume.bodyPart.length + incomingData.byteLength);
                        joined.set(consume.bodyPart);
                        joined.set(incomingData, consume.bodyPart.byteLength);
                        consume.bodyPart = joined;

                        /*let part = "";
                        for (var j = 0; j < consume.bodyPart.byteLength; j++) {
                            part += String.fromCharCode(consume.bodyPart[j]);
                        }
                        console.log(["PART STR", part]);*/

                        if (consume.remainingBytes === 0) {
                            //console.log(["BODY PART", consume.contentLength, consume.bodyPart.byteLength]);
                            var blob = new Blob([consume.bodyPart], {'type': 'image/jpeg'});
                            var url = URL.createObjectURL(blob);
                            var canvas = document.getElementById("canvas");
                            var ctx = canvas.getContext("2d");
                            var img = new Image;
                            img.onload = function() {
                                ctx.drawImage(img, 0, 0);
                            }
                            img.src = url;

                            consume.bodyPart = new Uint8Array();
                            consume.bytesToRead = 0;
                            consume.parserStatus = 0;
                        } else {
                            // Body part incomplete; continue to read next chunk.
                            //console.log(["REMAIN", consume.remainingBytes]);
                        }
                    } else if (chunk[i] === 10 || chunk[i] === 13) {
                        //console.log(["comapre boundary", line, consume.boundary]);
                        if (consume.line === consume.boundary) {
                            //console.log("BOUNDARY");
                            consume.parserStatus = 1;
                        } else {
                            if (consume.parserStatus == 1) {
                                // Reading headers
                                //console.log("headers");
                                if (consume.line === "") {
                                    consume.parserStatus = 2;
                                    //console.log(["START OF BODY", i]);
                                } else {
                                    let headerComponents = consume.line.split(":");
                                    if (headerComponents[0] === "Content-Id") {
                                        let contentId = parseInt(headerComponents[1]);
                                        //console.log(contentId);
                                    } else if (headerComponents[0] === "Content-Type") {
                                        //console.log(headerComponents);
                                    } else if (headerComponents[0] === "Content-Length") {
                                        consume.contentLength = parseInt(headerComponents[1]);
                                        consume.remainingBytes = consume.contentLength;
                                        //console.log([headerComponents[0], consume.contentLength]);
                                    } else if (headerComponents[0] === "Content-Timestamp") {
                                        let timestamp = parseFloat(headerComponents[1]);
                                        if (typeof consume.previousFrame !== "undefined") {
                                            $("#div-info").html(
                                                "Timestamp: " + timestamp + "<br/>" + 
                                                "Latency: " + (timestamp - consume.previousFrame));
                                        }
                                        consume.previousFrame = timestamp;
                                    }
                                }
                            } else {
                                console.log("exception");
                                consume.parserStatus = 0;
                            }
                        }
                        //console.log(["line", consume.line]);
                        consume.line = "";
                    } else {
                        consume.line += String.fromCharCode(chunk[i]);
                    }
                }

                return consume(responseReader);
            });
        }
        fetch(url).then(function (response) {
            let contentType = response.headers.get('Content-Type');
            let components  = contentType.split("=");
            if (components[0] === "multipart/x-mixed-replace;boundary") {
                var boundary = components[1];
                console.log(["Boundary of Multipart HTTP", boundary]);
            }
            return consume(response.body.getReader(), boundary);
        })
        .catch(console.log.bind(console));

        var xhr = new XMLHttpRequest();
        xhr.responseType = "arraybuffer";
        Object.defineProperty(xhr, 'responseText', {});
        xhr.open("GET", url, true);
        xhr.userdata = {
            "ResponseLimit": 0
        };
        xhr.onreadystatechange = function () {
            if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
                let contentType = xhr.getResponseHeader("Content-Type");
                let components  = contentType.split("=");
                if (components[0] === "multipart/x-mixed-replace;boundary") {
                    var boundary = components[1];
                    console.log(["Boundary of Multipart HTTP", boundary]);
                }
            } else if (xhr.readyState === XMLHttpRequest.LOADING) {
                //console.log(xhr.response);
                if (xhr.response !== null) {
                    let lines = xhr.response.split(/\r?\n/);
                    //console.log(lines[lines.length - 2]);
                    $("#div-canvas").html(lines[lines.length - 2]);
                }
                if (xhr.userdata.ResponseLimit >= 32) {
                    console.log("ABORT");
                    xhr.abort();
                }
                xhr.userdata.ResponseLimit += 1;
            }
            else if (xhr.readyState === XMLHttpRequest.DONE) {
                var status = xhr.status;
                console.log(["DONE", status]);
                if (status === 0 || (status >= 200 && status < 400)) {
                } else {
                }
            }
        };
        //xhr.send();
    });
</script>
</body>
</html>