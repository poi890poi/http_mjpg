<html>
<head>
    <title>Native HTTP/HTML Video Streaming</title>
    <script src="./js/jquery-3.5.1.min.js"></script>
</head>
<body>
    <div id="div-canvas">
        <img src=""></img>
    </div>
    <div id="div-info">
    </div>
<script>
    $( document ).ready(function() {
        console.log( "ready!" );

        var url = "http://localhost:8888";
        const consume = async function (responseReader, boundary) {
            if (typeof consume.boundary === "undefined") {
                console.log(["consume", boundary]);
                consume.boundary = "--" + boundary;
                consume.bytesToRead = 0;
                consume.line = "";
                consume.parserStatus = 0;
            }
            return responseReader.read().then(function (result) {
                if (result.done) { return; }

                // do something with the current chunk
                const chunk = result.value;

                // since the chunk can be multiple bytes, iterate through
                // each byte while skipping the byte order mark
                // (assuming UTF-8 with single-byte chars)
                console.log(["CHUNK", chunk.byteLength]);
                /*for (var i = 0; i < chunk.byteLength; i++) {
                    line += String.fromCharCode(chunk[i]);
                }
                console.log(line);
                line = '';*/
                for (var i = 0; i < chunk.byteLength; i++) {
                    if (consume.parserStatus == 2 && consume.bytesToRead > 0) {
                        consume.bodyPart = chunk.slice(i, i + consume.bytesToRead);
                        /*let bodyText = "";
                        for (var j = 0; j < body.byteLength; j++) {
                            bodyText += String.fromCharCode(body[j]);
                        }*/
                        console.log(["PART", consume.bytesToRead, consume.bodyPart.byteLength]);

                        /*let part = "";
                        for (var j = 0; j < consume.bodyPart.byteLength; j++) {
                            part += String.fromCharCode(consume.bodyPart[j]);
                        }
                        console.log(["PART STR", part]);*/

                        i += consume.bodyPart.byteLength;
                        if (consume.bytesToRead > consume.bodyPart.byteLength) {
                            // Body part incomplete; continue to read next chunk.
                            consume.bytesToRead -= consume.bodyPart.byteLength;
                            console.log(["REMAIN", consume.bytesToRead]);
                        } else {
                            consume.bytesToRead = 0;
                            consume.parserStatus = 0;
                        }
                    } else if (chunk[i] === 10 || chunk[i] === 13) {
                        //console.log(["comapre boundary", line, consume.boundary]);
                        if (consume.line === consume.boundary) {
                            console.log("BOUNDARY");
                            consume.parserStatus = 1;
                        } else {
                            if (consume.parserStatus == 1) {
                                // Reading headers
                                //console.log("headers");
                                if (consume.line === "") {
                                    consume.parserStatus = 2;
                                    console.log(["START OF BODY", i]);
                                } else {
                                    let headerComponents = consume.line.split(":");
                                    if (headerComponents[0] === "Content-Id") {
                                        let contentId = parseInt(headerComponents[1]);
                                        //console.log(contentId);
                                    } else if (headerComponents[0] === "Content-Type") {
                                        console.log(headerComponents);
                                    } else if (headerComponents[0] === "Content-Length") {
                                        consume.bytesToRead = parseInt(headerComponents[1]);
                                        console.log([headerComponents[0], consume.bytesToRead]);
                                    } else if (headerComponents[0] === "Timestamp") {
                                        let timestamp = parseFloat(headerComponents[1]);
                                        if (typeof consume.previousFrame !== "undefined") {
                                            $("#div-info").html(
                                                "Timestamp: " + timestamp + "<br/>" + 
                                                "Latency: " + (timestamp - consume.previousFrame));
                                        }
                                        consume.previousFrame = timestamp;
                                    }
                                }
                            } else {
                                console.log("exception");
                                consume.parserStatus = 0;
                            }
                        }
                        //console.log(["line", consume.line]);
                        consume.line = "";
                    } else {
                        consume.line += String.fromCharCode(chunk[i]);
                    }
                }

                return consume(responseReader);
            });
        }
        fetch(url).then(function (response) {
            let contentType = response.headers.get('Content-Type');
            let components  = contentType.split("=");
            if (components[0] === "multipart/x-mixed-replace;boundary") {
                var boundary = components[1];
                console.log(["Boundary of Multipart HTTP", boundary]);
            }
            return consume(response.body.getReader(), boundary);
        })
        .catch(console.log.bind(console));

        var xhr = new XMLHttpRequest();
        xhr.responseType = "arraybuffer";
        Object.defineProperty(xhr, 'responseText', {});
        xhr.open("GET", url, true);
        xhr.userdata = {
            "ResponseLimit": 0
        };
        xhr.onreadystatechange = function () {
            if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
                let contentType = xhr.getResponseHeader("Content-Type");
                let components  = contentType.split("=");
                if (components[0] === "multipart/x-mixed-replace;boundary") {
                    var boundary = components[1];
                    console.log(["Boundary of Multipart HTTP", boundary]);
                }
            } else if (xhr.readyState === XMLHttpRequest.LOADING) {
                //console.log(xhr.response);
                if (xhr.response !== null) {
                    let lines = xhr.response.split(/\r?\n/);
                    //console.log(lines[lines.length - 2]);
                    $("#div-canvas").html(lines[lines.length - 2]);
                }
                if (xhr.userdata.ResponseLimit >= 32) {
                    console.log("ABORT");
                    xhr.abort();
                }
                xhr.userdata.ResponseLimit += 1;
            }
            else if (xhr.readyState === XMLHttpRequest.DONE) {
                var status = xhr.status;
                console.log(["DONE", status]);
                if (status === 0 || (status >= 200 && status < 400)) {
                } else {
                }
            }
        };
        //xhr.send();
    });
</script>
</body>
</html>